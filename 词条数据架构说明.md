# 词条数据架构说明

## 概述

本架构将词条的处理逻辑从显示层移到了数据层，实现了词条数据的预计算和实时更新，提高了性能并便于后续处理。

## 核心概念

### 1. 词条来源类型 (sourceType)

每个词条都有明确的来源类型标识：

- `base`: 基础属性词条
- `rune`: 符文词条
- `runeWord`: 符文之语词条
- `set`: 套装词条
- `bond`: 羁绊词条
- `empower`: 赋能词条
- `soulCore`: 魂核词条

### 2. 词条状态 (isActive)

词条是否生效的状态：

- `true`: 词条生效，数值有效
- `false`: 词条不生效，数值为0

### 3. 计算值 (calculatedValue)

词条的实际生效数值，考虑了各种加成和条件：

- 基础词条：直接使用 `value`
- 套装词条：根据套装件数判断是否生效
- 羁绊词条：根据魂核等级判断是否生效
- 注灵词条：`value * multiplier`

## 数据结构

### CT 接口扩展

```typescript
export interface CT {
  // ... 原有属性
  sourceType?: string;    // 来源类型
  sourceCode?: string;    // 来源代码
  isActive?: boolean;     // 是否生效
  calculatedValue?: number; // 计算后的实际值
}
```

### 装备词条更新

```typescript
function updateEquipEntries(data: Cal2ContextType, equip: EquipDetail) {
  // 更新符文词条
  // 更新符文之语词条
  // 更新套装词条（实时计算套装件数）
  // 更新基础属性词条
  // 更新品质词条
}
```

### 技能词条更新

```typescript
function updateSkillEntries(data: Cal2ContextType, skill: SkillDetail) {
  // 更新主卡魂核词条
  // 更新副卡魂核词条
  // 更新羁绊词条（根据等级判断生效）
  // 更新赋能词条
  // 更新注灵词条
}
```

## 实时更新机制

### 1. 自动触发

```typescript
useEffect(() => {
  updateCalculatedEntries();
}, [data]);
```

每当 `data` 发生变化时，自动重新计算所有词条。

### 2. 手动触发

```typescript
const { updateCalculatedEntries } = useCal2();
updateCalculatedEntries(); // 手动触发更新
```

## 使用示例

### 显示套装词条

```typescript
{equip.zb.tzcts?.map((tzct: any) => (
  tzct.isActive && ( // 使用预计算的状态
    <div key={tzct.code}>
      {tzct.calculatedValue} {tzct.unit} {/* 使用预计算的值 */}
    </div>
  )
))}
```

### 显示羁绊词条

```typescript
{skill.zk.jbcts.filter(ct => ct.isActive).map(entry => (
  <div key={entry.code}>
    {entry.calculatedValue} {entry.unit} {/* 使用预计算的值 */}
  </div>
))}
```

## 优势

1. **性能提升**: 避免在每次渲染时重复计算
2. **数据一致性**: 所有组件使用相同的计算结果
3. **易于维护**: 计算逻辑集中管理
4. **便于扩展**: 新增词条类型只需在更新函数中添加逻辑
5. **实时性**: 数据变化时自动更新所有相关词条

## 注意事项

1. 确保在修改数据后调用 `updateCalculatedEntries()`
2. 新增词条类型时需要在相应的更新函数中添加处理逻辑
3. 词条的 `calculatedValue` 应该始终反映当前的实际生效值
